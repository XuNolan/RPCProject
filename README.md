1. 如果需要实现一个基础的RPC框架，需要考虑什么：
- 最基础的RPC方法即为“远程过程调用”，客户端向服务端发送封装了调用信息和参数的报文，指定调用对应方法；服务端接收对应报文，提取有效信息，调用本地方法，并将结果封装为响应报文发送给客户端。
    - 需要注意的是，其基本原则是，“对于客户端来说，调用RPC方法就像调用本地方法一样”，也就是说，客户端只管调用具体的方法，而方法->报文封装、发送、接收响应报文并返回，都是对于客户端透明的。
- 其次，再考虑RPC==框架==的实现。也就是再引入注册调度中心。

当前：先实现RPC核心的方法，需要完成当client调用server方法时，数据流向server处理后返回结果。
- 划分三个模块，server和client。common模块定义server提供的方法，以及共有的接口和类模式。

1. 如何将客户端对接口的调用转换为Request请求并通过网络IO发送？
   - 不能让客户端构造（自行定义的）包装类完成此步操作。不必须确保"客户端对远程过程调用完全不可见"
   - 引入代理模式。静态代理需要预先得知客户端会调用的所有方法。不太符合要求。故使用动态代理。
     - 动态代理选型？存在接口。使用jdk动态代理实现即可。
     - 静态代理也行？

2. 如何完成应用层的同步调用的逻辑？
    - 也就是说，在客户端发起方法调用后，在未收到响应报文时，应当阻塞，直到收到报文。
    - Future方法？

以下问题：
静态代理todo
粘包对应的decoder和encoder解决；注册解决；估计问题出在客户端的serviceImpl的阻塞上。