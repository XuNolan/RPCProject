本文档用于记录在实现过程中的一些想法和建议，当天日记和杂谈，进行当天学习内容和debug的总结。

9.25 周一。开始实现rpc框架。途中debug了以下问题：
- netty的责任链模式如何整合到项目流程内部；
- netty的粘包需要自行解决。参照guide-rpc框架的机制，在发送时先发送本包长度再发送实际数据，解包时根据长度从缓冲区中读取。
- netty的bug：客户端和服务端启动之后需要防止其直接退出。对于closeFuture要么使用sync同步阻塞，要么addListener在监听处理中进行线程池关闭。
- netty的bug：发送消息前注意处理信道不通的情况；
- netty在java11的时候好像要进行额外配置？反正当天晚上临走前把jdk调成8了。

9.26 周二上午：
- 日志系统引入。在不使用springbootstarter的情况下引入日志系统，需要：
1. 接口依赖
2. 日志实现依赖
3. 配置文件，放在resources中。
这个之前有接触但是一直没有实操。导致实际使用的时候还是有点不顺。
开会之前完成了收发。开会晚之后上课，阿巴巴巴。

6.27 周三晚
早上歇着了，晚上进行一个课的翘
1. 动态代理实现
2. 尝试整理代码。包括异常处理、响应操作、包名调整、方法封装。
3. 实验室学长提出可以考虑引入spock进行单元测试，且可以由客户端指定获取结果时使用同步响应还是异步响应（类dubbo）。这个之后再议。以及客户端与服务端的tcp连接应当保持，而不是每次调用时进行连接。


6.28 周四：整理代码
整理代码完毕。首次无bug使用泛型：p   整理的内容包括以下方面：
- 包结构（主打一个随自己心意）
- RpcResponse内部封装调用结果数据，外部包含code和desc；
- （运行时和非运行时）异常统一由RpcException处理。
  - 部分异常通过assert+catch exception进行处理。
- 二三点的code统一使用枚举量进行处理；
- 封装代理实例方法，使其与被代理对象类型无关
- 提取静态utils；

上述的代码整理大概是在整理过程中自然而然地写出来了。也许是因为之前有看到过，最近开会的内容也是整理代码。

整理代码完成后得到的bug：
1. 传输实体内部的对象成员也需要实现可序列化接口
2. optional不可用于序列化。（https://cloud.tencent.com/developer/article/1767915）
3. Java 官方不推荐Optional用在<u>实体属性</u>上(当时有警告，但当时不理解为什么)。Optional 推荐的用法是在<u>函数返回值</u>上。告诉函数调用者，返回的对象存在空异常的可能，需要调用者自行处理。
    - "这也是 Java 设计出 NotSerializableException 异常的原因之一
    - 其次，Optional 作为一个包装类，大量的 Optional 会<u>消耗过多的内存</u>。Optional 在字段中使用可能会浪费内存，并减慢数据结构的遍历速度。 
    - 第三，官方也不推荐在序列化、永久存储或通过网络传输中使用 Optional。 
    - 第四，在<u>方法</u>的参数中，也不推荐使用 Optional。
    - 第五，官方推荐通过在 <u>Stream 流管道</u>（或其他方法）返回 Optional。
    - 最后，在序列化方面。JDK 的序列化比较特殊，需要同时向前及向后兼容。
