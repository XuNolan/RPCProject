本文档用于记录在实现过程中的一些想法和建议，当天日记和杂谈，进行当天学习内容和debug的总结。

9.25 周一。开始实现rpc框架。途中debug了以下问题：
- netty的责任链模式如何整合到项目流程内部；
- netty的粘包需要自行解决。参照guide-rpc框架的机制，在发送时先发送本包长度再发送实际数据，解包时根据长度从缓冲区中读取。
- netty的bug：客户端和服务端启动之后需要防止其直接退出。对于closeFuture要么使用sync同步阻塞，要么addListener在监听处理中进行线程池关闭。
- netty的bug：发送消息前注意处理信道不通的情况；
- netty在java11的时候好像要进行额外配置？反正当天晚上临走前把jdk调成8了。

9.26 周二上午：
- 日志系统引入。在不使用springbootstarter的情况下引入日志系统，需要：
1. 接口依赖
2. 日志实现依赖
3. 配置文件，放在resources中。
这个之前有接触但是一直没有实操。导致实际使用的时候还是有点不顺。
开会之前完成了收发。开会晚之后上课，阿巴巴巴。

6.27 周三晚
早上歇着了，晚上进行一个课的翘
1. 动态代理实现
2. 尝试整理代码。包括异常处理、响应操作、包名调整、方法封装。
3. 实验室学长提出可以考虑引入spock进行单元测试，且可以由客户端指定获取结果时使用同步响应还是异步响应（类dubbo）。这个之后再议。以及客户端与服务端的tcp连接应当保持，而不是每次调用时进行连接。


6.28 周四：整理代码
整理代码完毕。首次无bug使用泛型：p   整理的内容包括以下方面：
- 包结构（主打一个随自己心意）
- RpcResponse内部封装调用结果数据，外部包含code和desc；
- （运行时和非运行时）异常统一由RpcException处理。
  - 部分异常通过assert+catch exception进行处理。
- 二三点的code统一使用枚举量进行处理；
- 封装代理实例方法，使其与被代理对象类型无关
- 提取静态utils；

上述的代码整理大概是在整理过程中自然而然地写出来了。也许是因为之前有看到过，最近开会的内容也是整理代码。

整理代码完成后得到的bug：
1. 传输实体内部的对象成员也需要实现可序列化接口
2. optional不可用于序列化。（https://cloud.tencent.com/developer/article/1767915）
3. Java 官方不推荐Optional用在<u>实体属性</u>上(当时有警告，但当时不理解为什么)。Optional 推荐的用法是在<u>函数返回值</u>上。告诉函数调用者，返回的对象存在空异常的可能，需要调用者自行处理。
    - "这也是 Java 设计出 NotSerializableException 异常的原因之一
    - 其次，Optional 作为一个包装类，大量的 Optional 会<u>消耗过多的内存</u>。Optional 在字段中使用可能会浪费内存，并减慢数据结构的遍历速度。 
    - 第三，官方也不推荐在序列化、永久存储或通过网络传输中使用 Optional。 
    - 第四，在<u>方法</u>的参数中，也不推荐使用 Optional。
    - 第五，官方推荐通过在 <u>Stream 流管道</u>（或其他方法）返回 Optional。
    - 最后，在序列化方面。JDK 的序列化比较特殊，需要同时向前及向后兼容。

周五周六，大概看了一下反射 异常处理和spi。不太清楚之后需要先做什么。

周天：
1. 添加了kryo序列化逻辑。添加功能的大概一般逻辑
   - 待添加框架或插件等的大概处理逻辑，本程序内部需要额外调用的有哪些方法；
   - 待添加的框架对象的初始化和消亡在本程序内部的位置
   - 本程序内部需要额外调用的方法与上一步设计的对象生命周期是否有冲突
   - 以及，对于已有代码添加额外功能，尽量减少原有代码的更改。根据原有代码的使用情况设计新功能类中提供的方法和入参和出参。
     - 比如此前没有参考guide的时候，自己是想，只把kryo的创建提取出类，而将使用kryo序列化和反序列化的所有逻辑嵌入原程序已有的decoder和encoderhandler中。
       - 重复代码过多，错误处理和kryo和文件资源释放也有点乱。对decoder和encoderhandler内部代码改动过多。
     - 而在guide中，提取出了serializer类接口，并将序列化与反序列化的方法全部封装到kryoSerilizer实现类中。根据decoder和encoder使用情况设计入参和出参。
     - 好处不言而喻，也利于此后其他序列化框架的引入。且encoder和decoder的改动也降到了最少。仍然可以获取到byte字节（利于获取长度）或反序列化得到的对象。

周一：
- 引入服务注册和发现逻辑，但是出现报错。Connection refused: /127.0.0.1:9848，并最终落到注册服务失败。
- 推测是nacos的问题。之前rms项目中也存在读取不到nacos配置的问题。两个方向：
  - 没有出现nacos的配置，这有点反常理；回顾nacos的启动，出现`docker run -d -p 8848:8848 -e MODE=standalone -v /Users/xubin/nacos/init.d/custom.properties:/home/nacos/init.d/custom.properties -v /Users/xubin/nacos/logs:/home/nacos/logs --restart always --name nacos nacos/nacos-server`
    - 即，涉及nacos/init.d/custom.properties文件，内部management.endpoints.web.exposure.include=*
    - 开放全部的对外监控的节点，这个应该没有问题
  - 另一个问题有可能是客户端与服务端无法创建链接；telnet试图连接nacos失败；
  - 在按照教程上在映射8848的端口之后额外映射9848，即添加-p 9848:9848即可正常连接。
- 此外，nacos只是提供了服务与地址的映射。实际服务获取的流程还是需要客户端和服务端来完成。也就是说，服务端在向nacos注册服务之外，对于自己提供的服务map还是需要在本地进行保存。本地保存的map与服务注册并不冲突。
