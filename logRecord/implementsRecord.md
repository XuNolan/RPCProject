本文档用于记录实现的思路、实现选用的方法和方向等。用于确保当前的思路不会过于庞大和混乱。


1.如果需要实现一个基础的RPC框架，需要考虑什么：
- 最基础的RPC方法即为“远程过程调用”，客户端向服务端发送封装了调用信息和参数的报文，指定调用对应方法；服务端接收对应报文，提取有效信息，调用本地方法，并将结果封装为响应报文发送给客户端。
    - 需要注意的是，其基本原则是，“对于客户端来说，调用RPC方法就像调用本地方法一样”，也就是说，客户端只管调用具体的方法，而方法->报文封装、发送、接收响应报文并返回，都是对于客户端透明的。
- 其次，再考虑RPC==框架==的实现。也就是再引入注册调度中心。

当前：先实现RPC核心的方法，需要完成当client调用server方法时，数据流向server处理后返回结果。
- 划分三个模块，server和client。common模块定义server提供的方法，以及共有的接口和类模式。

1. 如何将客户端对接口的调用转换为Request请求并通过网络IO发送？
    - 不能让客户端构造（自行定义的）包装类完成此步操作。不必须确保"客户端对远程过程调用完全不可见"
    - 引入代理模式。静态代理需要预先得知客户端会调用的所有方法。不太符合要求。故使用动态代理。
        - 动态代理选型？存在接口。使用jdk动态代理实现即可。
        - 静态代理也行？

2. 如何完成应用层的同步调用的逻辑？
    - 也就是说，在客户端发起方法调用后，在未收到响应报文时，应当阻塞，直到收到报文。
    - Future方法。可以实现。

上述已经完成

接下来的目标是按着guide的优化路线继续，还是说先看spi？
按着guide的优化路线先写。稍微看了一下spi并不是特别能看懂，也许是放假放了一段时间脑子不转了；

以下copy自guide的rpc框架；

还有没做的，包括异常处理handler和netty心跳与连接断开配置。

这段时间还是以实操为主吧。
1. jdk改其他序列化；
- 是否有更好的序列化方式？
2. zookeeper管理相关地址信息。可否用nacos？https://juejin.cn/post/7068065361312088095
   - 选用nacos进行服务注册和发现。https://developer.aliyun.com/article/930139
   - nacos在之前已经配好了。启动docker即可。
此前，客户端在调用具体服务之前，需根据写死的inetSocket完成netty的初始化并连接到服务端。此前的项目结构只包含两个端点。
   - 引入nacos之后，引入第三个端点，即nacos服务监听和发现端点。
   - 服务端在netty的bind接收客户端请求之前，需首先将自己的地址和提供的服务提供至nacos处；
   - 客户端在与服务端建立连接之前，需首先与nacos端建立连接并获取服务的地址，根据得到的地址负载均衡再连接至对应的服务端。
   - 以及，nacos与服务端和客户端同时建立长连接；nacos监听到服务端服务发生变化时，主动以最小信息（事件+请求地址）通知客户端，客户端主动从对应的请求地址再次请求所需的信息。称为"推拉结合"
   - 从服务端的服务注册开始进行完善

- [X]  **使用开源的序列化机制 Kyro（也可以用其它的）替代 JDK 自带的序列化机制；**
- [X]  **使用 Zookeeper 管理相关服务地址信息**
- [ ]  Netty 重用 Channel 避免重复连接服务端
- [X]  使用 `CompletableFuture` 包装接受客户端返回结果（之前的实现是通过 `AttributeMap` 绑定到 Channel 上实现的） 详见：使用 CompletableFuture 优化接受服务提供端返回结果
- [ ]  **增加 Netty 心跳机制** : 保证客户端和服务端的连接不被断掉，避免重连。
- [ ]  **客户端调用远程服务的时候进行负载均衡** ：调用服务的时候，从很多服务地址中根据相应的负载均衡算法选取一个服务地址。ps：目前实现了随机负载均衡算法与一致性哈希算法。
- [ ]  **处理一个接口有多个类实现的情况** ：对服务分组，发布服务的时候增加一个 group 参数即可。
- [ ]  **集成 Spring 通过注解注册服务**
- [ ]  **集成 Spring 通过注解进行服务消费** 。
- [ ]  **增加服务版本号** ：建议使用两位数字版本，如：1.0，通常在接口不兼容时版本号才需要升级。为什么要增加服务版本号？为后续不兼容升级提供可能，比如服务接口增加方法，或服务模型增加字段，可向后兼容，删除方法或删除字段，将不兼容，枚举类型新增字段也不兼容，需通过变更版本号升级。
- [ ]  **对 SPI 机制的运用**
- [ ]  **增加可配置比如序列化方式、注册中心的实现方式,避免硬编码** ：通过 API 配置，后续集成 Spring 的话建议使用配置文件的方式进行配置
- [ ]  **客户端与服务端通信协议（数据包结构）重新设计** ，可以将原有的 `RpcRequest`和 `RpcReuqest` 对象作为消息体，然后增加如下字段（可以参考：《Netty 入门实战小册》和 Dubbo 框架对这块的设计）：
    - **魔数** ： 通常是 4 个字节。这个魔数主要是为了筛选来到服务端的数据包，有了这个魔数之后，服务端首先取出前面四个字节进行比对，能够在第一时间识别出这个数据包并非是遵循自定义协议的，也就是无效数据包，为了安全考虑可以直接关闭连接以节省资源。
    - **序列化器编号** ：标识序列化的方式，比如是使用 Java 自带的序列化，还是 json，kyro 等序列化方式。
    - **消息体长度** ： 运行时计算出来。
    - ......
- [ ]  **编写测试为重构代码提供信心**
- [ ]  **服务监控中心（类似dubbo admin）**
- [ ]  **设置 gzip 压缩**


